#+html_head: <link rel="stylesheet" href="../modulus-style.css" type="text/css"/>
#+title: Tutorial: Custom Data
#+options: toc:nil num:nil html-postamble:nil

#+html: <div style="text-align:right">
[[file:../index.org][Modulus]] / [[file:index.org][Tutorials]] / Custom Data
#+html: </div>

* Build Data
#+begin_src modulus
(induct (MyBool : ğ’°)
  (my-true : MyBool)
  (my-false : MyBool))
#+end_src

#+begin_src modulus
(induct (Vehicle : ğ’°)
  (bike  : Vehicle)
  (car   : Vehicle)
  (truck : Int â†’ Vehicle))
#+end_src


#+begin_src modulus
(induct (Nat : ğ’°)
  (zero : Nat)
  (succ : Nat â†’ Nat))
#+end_src

* Coinduction

** Basic Codata
#+begin_src modulus
(coinduct (CoBool : ğ’°)
  (my-if : CoBool â†’ {A : ğ’°} â†’ A â†’ A â†’ A))

(def my-true (comatch (my-if iftrue iffalse â†’ iftrue)))

(def my-false (comatch (my-if iftrue iffalse â†’ iftrue)))

(def my-false' (comatch (my-if {A} iftrue iffalse â†’ iftrue)))
#+end_src


** Recursive & Infinite Codata 
Natural Numbers 

#+begin_src modulus
(coinduct (CoNat [A] : ğ’°)
  (pred : CoNat â†’ CoNat))
#+end_src

#+begin_src modulus
(coinduct (CoNat [A] : ğ’°)
  (pred : CoNat â†’ CoNat))
#+end_src

*** Infinite Codata


** Parametrized Codata: Streams
#+begin_src modulus
(coinduct (CoList [A] : ğ’°)
  (head : CoList A â†’ Maybe A)
  (tail : CoList A â†’ Maybe (MyList A)))
#+end_src

#+begin_src modulus
(defn colen-bad
  ...)
#+end_src

#+begin_src modulus
(colen : {A} â†’ CoList A â†’ CoNat)
(defn colen [colist]
  (match (tail colist) 
    (Just tl â†’ comatch
      (pred â†’ (len tl)))
    (Nothing â†’ comatch
      (pred â†’ cozero))))
#+end_src

#+begin_src modulus
(coinduct (Stream [A] : ğ’°)
  (value : Stream A â†’ A)
  (next : Stream A â†’ MyList A))
#+end_src

* When to Use Data & Codata
For the most part, regular inductive data types are easier to work with than
their co-inductive counterparts. However, there are scenarios in which codata is
useful - primarily when you are writing algorithms which explore an /infinite/
search space. 

As an example, consider a Chess AI. We might have datatypes for pieces and moves

#+begin_src modulus
(enum Colour [White Black])
(enum Rank [Pawn Rook Knight ...])

(def Piece (Colour * Rank))

(def Board (Tensor â¦—8 8â¦˜ Piece)
#+end_src




