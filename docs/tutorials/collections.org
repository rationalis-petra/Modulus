#+html_head: <link rel="stylesheet" href="../modulus-style.css" type="text/css"/>
#+title: Tutorial: Collections
#+options: toc:nil num:nil html-postamble:nil

#+html: <div style="text-align:right">
[[file:../index.org][Modulus]] / [[file:index.org][Tutorials]] / Projects
#+html: </div>



* Types and Arrays
Modulus is what is known as a statically typed language. A type is like a
category of values - for example, =Integer= is the type of values which are
whole numbers. An equally common type is =String=, which is a sequence of
Characters. For example, "hello" and "my name is chris" are both
Strings. Modulus uses types to catch errors before you run your program. As an
example, suppose you write =pi + 2=, expecting =pi= to hold the value
=3.14159...=. However, someone decided to set it to the string "pi". In this
case, Modulus will report a /type error/, because + both inputs to have the type
=Integer=, but you gave it a =String=.




Modulus also allows you to group data together into structures called /arrays/,
which you can thing of as a collection of values. Arrays are written as a list
of values between 'tortoise' brackets =⦗⦘=, (these have codes =;[​[= and =;]​]=,
or =:left-tortoise= and =:right-tortoise=). For example, the array containing the
numbers 1, 2 and 3 is written =⦗1 2 3⦘=.



It's cool to be able to make an array, but what can we /do/ with them? For a
start, we can join them together with /append/, (also written `⋅' (=;**=)).

#+begin_src modulus
> ⦗1 2 3⦘ ⋅ ⦗4 5 6⦘
⦗1 2 3 4 5 6⦘
> append ⦗1 2 3⦘ ⦗4 5 6⦘
⦗1 2 3 4 5 6⦘
#+end_src


* Higher-Order Functions

#+begin_src modulus
> defn add1 [x] (x + 1)
> map add1 ⦗1 2 3⦘
⦗2 3 4⦘
#+end_src

#+begin_src 
> map (+ 1) ⦗1 2 3⦘
⦗2 3 4⦘
#+end_src

#+begin_src 
> (+ 1) ¨ ⦗1 2 3⦘
⦗2 3 4⦘
#+end_src

#+begin_src modulus
> defn add [x y] (x + y)
> fold add 0 ⦗1 2 3⦘
6
#+end_src

#+begin_src modulus
> foldl (+) 0 ⦗1 2 3⦘
#+end_src

#+begin_src modulus
> ((+) / 0) ⦗1 2 3⦘
#+end_src

#+begin_src modulus
> (+ / 0) ⦗1 2 3⦘
#+end_src

#+begin_src modulus
> + ⟨/ 0⟩ ⦗1 2 3⦘
#+end_src

* Useful Array functions

filter

#+begin_src modulus
> even? n ≜ (n | 2 = 0)
⦗1 2 3⦘ ⟨◉ ,⟩ ⦗⁖a ⁖b ⁖c⦘
> ⦗⦗1 ⁖a⦘ ⦗1 ⁖b⦘ ⦗1 ⁖c⦘
   ⦗2 ⁖a⦘ ⦗2 ⁖b⦘ ⦗2 ⁖c⦘
   ⦗3 ⁖a⦘ ⦗3 ⁖b⦘ ⦗3 ⁖c⦘⦘
#+end_src

filter

#+begin_src modulus
⦗1 2 3⦘ ⟨◉ ,⟩ ⦗⁖a ⁖b ⁖c⦘
> ⦗⦗1 ⁖a⦘ ⦗1 ⁖b⦘ ⦗1 ⁖c⦘
   ⦗2 ⁖a⦘ ⦗2 ⁖b⦘ ⦗2 ⁖c⦘
   ⦗3 ⁖a⦘ ⦗3 ⁖b⦘ ⦗3 ⁖c⦘⦘
#+end_src

inner-product

#+begin_src modulus
> ⦗1 2 3⦘ ⟨⊙ ,⟩ ⦗⁖a ⁖b ⁖c⦘
⦗(1, ⁖a) (2, ⁖b) (3, ⁖c)⦘
#+end_src

outer-product

#+begin_src modulus
⦗1 2 3⦘ ⟨◉ ,⟩ ⦗⁖a ⁖b ⁖c⦘
> ⦗⦗1 ⁖a⦘ ⦗1 ⁖b⦘ ⦗1 ⁖c⦘
   ⦗2 ⁖a⦘ ⦗2 ⁖b⦘ ⦗2 ⁖c⦘
   ⦗3 ⁖a⦘ ⦗3 ⁖b⦘ ⦗3 ⁖c⦘⦘
#+end_src

